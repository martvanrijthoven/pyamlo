{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PYAMLO Documentation","text":"<p>Development Status</p> <p>PYAMLO is currently in development. The API is not stable and may change without notice.</p> <p>Welcome to the official documentation for PYAMLO.</p> <p>PYAMLO is a  YAML configuration loader for Python, designed for advanced configuration scenarios. It supports file inclusion, deep merging, environment variable injection, variable interpolation, and direct object instantiation.</p>"},{"location":"#why-pyamlo","title":"Why PYAMLO?","text":"<ul> <li>Composable configs: Use <code>include!</code> to merge multiple YAML files.</li> <li>Powerful merging: Deep merge, extend lists, or patch dicts.</li> <li>Environment aware: Inject environment variables and use defaults.</li> <li>Python objects: Instantiate classes/functions directly from YAML</li> <li>Interpolation: <ul> <li>Variables: Use <code>${var}</code> to reference other config values.</li> <li>Strings: Use <code>${var}_my_string</code> to reference other config values combined with strings.</li> <li>Instances: Use <code>${object.property}</code> to reference instantiated objects and their properties.</li> </ul> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>pip install pyamlo\n</code></pre> <p>Given a simple YAML file <code>config.yaml</code>:</p> <pre><code>app:\n  name: MyWebApp\n  port: 8080\n  host: web.local\ngreeting: Hello, ${app.name}!\ndatabase_url: postgres://${app.host}:${app.port}/maindb\n</code></pre> <p>You can load and resolve it using PYAMLO:</p> <pre><code>from pyamlo import load_config\nwith open(\"config.yaml\") as f:\n    config = load_config(f)\nprint(config['greeting'])  # Hello, MyWebApp!\nprint(config['database_url'])  # postgres://web.local:8080/maindb\n</code></pre>"},{"location":"best-practices/","title":"Best Practices","text":""},{"location":"best-practices/#avoiding-common-pitfalls","title":"Avoiding Common Pitfalls","text":"<ul> <li>Do not use <code>!patch</code> unless you want to fully replace a dictionary.</li> <li>Use <code>!extend</code> only on lists.</li> <li>Use <code>${...}</code> for referencing both config values and object attributes.</li> </ul>"},{"location":"best-practices/#using-environment-variables","title":"Using Environment Variables","text":"<ul> <li>Always provide a default for non-critical env vars:   <pre><code>db_url: !env {var: DATABASE_URL, default: \"sqlite:///default.db\"}\n</code></pre></li> </ul>"},{"location":"best-practices/#cli-overrides-best-practices","title":"CLI Overrides Best Practices","text":""},{"location":"best-practices/#programmatic-vs-command-line-usage","title":"Programmatic vs Command Line Usage","text":"<p>PYAMLO supports overrides in two ways:</p> <p>Programmatic overrides (via <code>overrides</code> parameter): <pre><code>from pyamlo import load_config\n\n# Manual overrides for specific values\nconfig = load_config(\"config.yml\", overrides=[\n    \"pyamlo.app.debug=true\",\n    \"pyamlo.database.host=localhost\"\n])\n\n# Automatic CLI reading\nconfig = load_config(\"config.yml\", use_cli=True)\n\n# Combined approach\nconfig = load_config(\"config.yml\", \n    overrides=[\"pyamlo.app.name=MyApp\"],  # Always applied\n    use_cli=True  # Read additional overrides from command line\n)\n</code></pre></p> <p>Command line usage: <pre><code>python -m pyamlo config.yml pyamlo.app.debug=true pyamlo.database.host=localhost\n</code></pre></p>"},{"location":"best-practices/#namespace-your-arguments","title":"Namespace Your Arguments","text":"<ul> <li>Always use the <code>pyamlo.</code> prefix for PYAMLO config overrides</li> <li>This avoids conflicts with other CLI arguments <pre><code># Good\npython script.py pyamlo.app.name=MyApp --verbose\n\n# Bad - no pyamlo prefix, will be ignored\npython script.py app.name=MyApp --verbose\n</code></pre></li> </ul>"},{"location":"best-practices/#use-proper-yaml-syntax-in-values","title":"Use Proper YAML Syntax in Values","text":"<ul> <li>Use single quotes for values containing spaces or special characters</li> <li>Use valid YAML for !extend and !patch values <pre><code># Good\npython script.py 'pyamlo.items=!extend [4,5]' 'pyamlo.settings=!patch {\"debug\": true}'\n\n# Bad - invalid YAML syntax\npython script.py pyamlo.items=!extend[4,5] pyamlo.settings=!patch{debug:true}\n</code></pre></li> </ul>"},{"location":"best-practices/#order-of-precedence","title":"Order of Precedence","text":"<ol> <li>Included file values (!include)</li> <li>Config file values (loaded from YAML files)</li> <li>Manual overrides (provided via <code>overrides</code> parameter)</li> <li>CLI overrides (when <code>use_cli=True</code>, read from sys.argv)</li> </ol> <p>When both manual overrides and CLI overrides are used together, they are combined with manual overrides processed first, then CLI overrides applied on top.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page provides quick examples of PYAMLO's core features. For a comprehensive, real-world example, see the PyTorch Ignite Tutorial which demonstrates a complete machine learning training pipeline using modular configuration.</p>"},{"location":"examples/#minimal-example","title":"Minimal Example","text":"<pre><code>app:\n  name: MinimalApp\n  version: 1.0\n</code></pre>"},{"location":"examples/#multi-file-include","title":"Multi-file Include","text":"<pre><code>include!:\n  - base.yaml\n  - override.yaml\n</code></pre>"},{"location":"examples/#positional-include-include_at","title":"Positional Include (<code>!include_at</code>)","text":"<p>Place file contents at specific positions in your configuration:</p> <pre><code>app:\n  name: MyApp\n  version: 1.0\n\n# Include middleware config at this exact position\nmiddleware: !include_at middleware.yml\n\ndatabase:\n  host: localhost\n  port: 5432\n</code></pre> <p>Where <code>middleware.yml</code> contains: <pre><code>middleware:\n  cache:\n    enabled: true\n    ttl: 3600\n  monitoring:\n    enabled: true\n    port: 9090\n</code></pre></p> <p>Result merges the contents at the position of <code>middleware</code>: <pre><code>app:\n  name: MyApp\n  version: 1.0\nmiddleware:\n  cache:\n    enabled: true\n    ttl: 3600\n  monitoring:\n    enabled: true\n    port: 9090\ndatabase:\n  host: localhost\n  port: 5432\n</code></pre></p> <p>Note: Included files must contain keys matching the assignment target. Keys starting with underscore are always allowed as helper keys.</p>"},{"location":"examples/#variable-interpolation-in-include-paths","title":"Variable Interpolation in Include Paths","text":"<pre><code>environment: production\nservice_type: api\n\n# Dynamic path based on variables\nconfig: !include_at configs/${environment}/${service_type}.yml\n</code></pre> <p>This resolves to <code>configs/production/api.yml</code>.</p>"},{"location":"examples/#environment-variable-with-default","title":"Environment Variable with Default","text":"<pre><code>api_key: !env {var: API_KEY, default: \"not-set\"}\n</code></pre>"},{"location":"examples/#python-module-import","title":"Python Module Import","text":"<pre><code># Import a class\ndatetime: !import datetime.datetime\n\n# use the imported class\ncurrent_time: !@pyamlo.call ${datetime.now}\n</code></pre>"},{"location":"examples/#python-object-instantiation","title":"Python Object Instantiation","text":"<pre><code>log_path: !@pathlib.Path /var/log/myapp.log\n</code></pre>"},{"location":"examples/#advanced-usage","title":"Advanced Usage","text":"<p>.</p>"},{"location":"examples/#deep-merging-dict-patching-and-list-extension","title":"Deep Merging, Dict Patching and List Extension","text":"<p><pre><code>include!:\n  - base.yaml\n\nusers:\n  admin: !patch \n    user: root\n    id: 1\n  guests: !extend [\"guest2\"]\n</code></pre> Where <code>base.yaml</code> contains: <pre><code>users:\n  admin:\n    name: root\n    value: 1\n  guests: [\"guest1\"]\n</code></pre> Result: <code>admin</code> is <code>{'user': 'root', 'id': 1}</code>, <code>guests</code> is <code>[\"guest1\", \"guest2\"]</code>.</p>"},{"location":"examples/#python-object-instantiation_1","title":"Python Object Instantiation","text":"<pre><code># Use hierarchical path references\nmain_db: !@mydb.Database\n  dsn: ${db_url}\n  pool_size: 10\n\nworker: !@myapp.Worker\n  db: ${main_db}\n\n# References follow YAML structure\napp:\n  db_connection: ${main_db}\n  worker_instance: ${worker}\n</code></pre> <p>Reference Python objects via <code>${main_db}</code> elsewhere in the config.</p>"},{"location":"examples/#advanced-variable-interpolation","title":"Advanced Variable Interpolation","text":"<p>Note</p> <p>The <code>ml</code> module used in this example is fictional and used for demonstration purposes only. It illustrates how you might structure a machine learning pipeline configuration using PYAMLO's variable interpolation features.</p> <pre><code>pipeline:\n  preprocess: !@ml.PreprocessStep\n    name: preprocess\n  train: !@ml.TrainStep\n    name: train\n    inputs: ${pipeline.preprocess.outputs}\n  evaluate: !@ml.EvaluateStep\n    name: evaluate\n    inputs: ${pipeline.train.outputs}\n</code></pre>"},{"location":"examples/#overrides","title":"Overrides","text":"<pre><code>from pyamlo import load_config\nconfig = load_config(\"config.yaml\", overrides=[\n    \"pyamlo.app.name=NewApp\",\n    \"pyamlo.database.host=localhost\"\n])\n</code></pre>"},{"location":"examples/#cli-overrides","title":"CLI Overrides","text":"<pre><code>python -m pyamlo config.yaml pyamlo.app.name=NewApp pyamlo.database.host=localhost\n</code></pre> <pre><code>from pyamlo import load_config\nconfig = load_config(\"config.yaml\", use_cli=True)\n</code></pre>"},{"location":"examples/#complete-examples","title":"Complete Examples","text":""},{"location":"examples/#pytorch-ignite-training-pipeline","title":"PyTorch Ignite Training Pipeline","text":"<p>For a comprehensive example demonstrating PYAMLO's capabilities in a real machine learning project, see the PyTorch Ignite Tutorial. This example shows:</p> <ul> <li>Modular Configuration: Split complex ML pipelines into focused, reusable components</li> <li>Automatic Device Detection: Conditional CUDA/CPU configuration</li> <li>Object Instantiation: Creating PyTorch models, optimizers, and training engines from YAML</li> <li>Variable Interpolation: Sharing objects and values across configuration files</li> <li>Advanced Patterns: Environment variables, conditional logic, and command-line overrides</li> </ul> <p>The tutorial includes both monolithic and modular approaches, demonstrating how to scale from simple prototypes to complex ML configurations.</p>"},{"location":"features/","title":"Features","text":"<p>PYAMLO enhances standard YAML loading with several powerful features designed to handle complex configurations.</p>"},{"location":"features/#includes-include","title":"Includes (<code>include!</code>)","text":"<ul> <li>Structure your configuration across multiple files using the <code>include!</code> key.</li> <li>Files are deep-merged in order, with later files overriding earlier ones.</li> </ul>"},{"location":"features/#positional-includes-include_at","title":"Positional Includes (<code>!include_at</code>)","text":"<p>Include files at specific positions in your configuration, replacing the key with the file's contents.</p> <pre><code>app:\n  name: MyApp\n  version: 1.0\n\n# Include middleware config at this exact position\nmiddleware: !include_at middleware.yml\n\ndatabase:\n  host: localhost\n</code></pre> <p>Where <code>middleware.yml</code> contains: <pre><code>middleware:\n  cache:\n    enabled: true\n    ttl: 3600\n  monitoring:\n    enabled: true\n    port: 9090\n</code></pre></p> <p>The result merges the included content directly into the configuration: <pre><code>app:\n  name: MyApp\n  version: 1.0\nmiddleware:\n  cache:\n    enabled: true\n    ttl: 3600\n  monitoring:\n    enabled: true\n    port: 9090\ndatabase:\n  host: localhost\n</code></pre></p>"},{"location":"features/#key-validation","title":"Key Validation","text":"<p><code>!include_at</code> validates that included files only contain expected keys. This prevents configuration errors from unexpected content:</p> <pre><code># Single key - file must contain 'config' key\nconfig: !include_at config.yml\n\n# Multiple keys - file must contain 'train_loader' and 'val_loader' keys  \ntrain_loader, val_loader: !include_at loaders.yml\n</code></pre> <p>Keys starting with underscore (e.g., <code>_helper</code>) are always allowed as private/helper keys.</p>"},{"location":"features/#variable-interpolation-in-include-paths","title":"Variable Interpolation in Include Paths","text":"<p>Use variable interpolation in file paths for dynamic includes:</p> <pre><code>environment: production\nservice_type: api\n\n# Dynamic path based on variables\nconfig: !include_at configs/${environment}/${service_type}.yml\n</code></pre> <p>This resolves to <code>configs/production/api.yml</code>. Variables are resolved from the current configuration context.</p>"},{"location":"features/#multiple-config-files","title":"Multiple Config Files","text":"<ul> <li>Load and merge multiple configuration files in a single call.</li> <li>Each file processes <code>!include</code> directives independently relative to its own location.</li> <li>Files are merged in order with later files overriding earlier ones.</li> <li>Perfect for environment-specific overrides, user customizations, and modular configurations.</li> </ul> <pre><code># Load base config, then environment-specific, then user overrides\nconfig = load_config(['base.yaml', 'production.yaml', 'user-override.yaml'])\n</code></pre>"},{"location":"features/#merging-strategies","title":"Merging Strategies","text":"<ul> <li>Deep Merge: Recursively merges dictionaries.</li> <li>List Extension (<code>!extend</code>): Appends to lists.</li> <li>Dictionary Replacement (<code>!patch</code>): Replaces dictionaries.</li> </ul>"},{"location":"features/#environment-variables-env","title":"Environment Variables (<code>!env</code>)","text":"<ul> <li>Inject environment variables directly into your config.</li> <li>Supports default values: <code>!env {var: NAME, default: ...}</code></li> </ul>"},{"location":"features/#python-module-import-import","title":"Python Module Import (<code>!import</code>)","text":"<ul> <li>Import Python modules, classes, or functions without instantiation.</li> </ul>"},{"location":"features/#python-object-instantiation","title":"Python Object Instantiation (<code>!@</code>)","text":"<ul> <li>Instantiate Python classes or call functions directly from YAML.</li> <li>Supports positional, keyword, and scalar arguments.</li> </ul>"},{"location":"features/#variable-interpolation-expressions","title":"Variable Interpolation &amp; Expressions (<code>${...}</code>)","text":"<p>Reference other config values, perform calculations, and evaluate conditions within your YAML configuration.</p>"},{"location":"features/#basic-variable-references","title":"Basic Variable References","text":"<pre><code>app:\n  name: MyApp\n  version: 1.0\n  title: ${app.name} v${app.version}  # \"MyApp v1.0\"\n</code></pre>"},{"location":"features/#mathematical-expressions","title":"Mathematical Expressions","text":"<p>Perform calculations using standard Python operators: <pre><code>server:\n  workers: 4\n  connections_per_worker: 100\n  max_connections: ${server.workers * server.connections_per_worker}  # 400\n\npricing:\n  base_price: 10.0\n  tax_rate: 0.21\n  total: ${pricing.base_price * (1 + pricing.tax_rate)}  # 12.1\n</code></pre></p>"},{"location":"features/#conditional-expressions","title":"Conditional Expressions","text":"<p>Use Python-style conditionals for dynamic configuration: <pre><code>app:\n  env: production\n  debug: ${app.env == 'development'}  # false\n\ndatabase:\n  pool_size: ${app.env == 'production' if 50 else 10}  # 50\n  host: ${app.env == 'production' if 'prod.db.com' else 'localhost'}\n\nfeatures:\n  enable_cache: ${app.env in ['production', 'staging']}\n  log_level: ${'ERROR' if app.env == 'production' else 'DEBUG'}\n</code></pre></p>"},{"location":"features/#logical-operations","title":"Logical Operations","text":"<p>Combine conditions with <code>and</code>, <code>or</code>, and <code>not</code>: <pre><code>app:\n  env: production\n  maintenance_mode: false\n\napi:\n  enabled: ${app.env == 'production' and not app.maintenance_mode}\n  rate_limiting: ${app.env == 'production' or app.env == 'staging'}\n</code></pre></p>"},{"location":"features/#object-property-access","title":"Object Property Access","text":"<p>Access properties of instantiated objects: <pre><code>database: !@ psycopg2.connect\n  host: localhost\n  port: 5432\n\nconnection_string: ${database.host}:${database.port}  # \"localhost:5432\"\n</code></pre></p>"},{"location":"features/#bitwise-operations","title":"Bitwise Operations","text":"<p>Perform bitwise operations for flags, permissions, and low-level data manipulation: <pre><code>permissions:\n  read: 4    # Binary: 100\n  write: 2   # Binary: 010\n  execute: 1 # Binary: 001\n\n  # Combine permissions using bitwise OR\n  full_access: ${permissions.read | permissions.write | permissions.execute}  # 7\n\n  # Check if permission is granted using bitwise AND\n  can_read: ${permissions.full_access &amp; permissions.read}  # 4 (truthy)\n\n  # Remove permission using bitwise AND with NOT\n  no_write: ${permissions.full_access &amp; ~permissions.write}  # 5\n\nflags:\n  debug: 1\n  verbose: 2\n  current: ${flags.debug | flags.verbose}  # 3\n  shift_left: ${flags.debug &lt;&lt; 2}          # 4 (multiply by 4)\n  shift_right: ${flags.verbose &gt;&gt; 1}       # 1 (divide by 2)\n</code></pre></p> <p>Supported Operations: - Math: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code> - Bitwise: <code>&amp;</code> (AND), <code>|</code> (OR), <code>^</code> (XOR), <code>~</code> (NOT), <code>&lt;&lt;</code> (left shift), <code>&gt;&gt;</code> (right shift) - Comparison: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>in</code> - Logical: <code>and</code>, <code>or</code>, <code>not</code> - Ternary: <code>value_if_true if condition else value_if_false</code></p>"},{"location":"features/#cli-overrides","title":"CLI Overrides","text":"<p>Override configuration values via command-line arguments using the <code>pyamlo.</code> prefix:</p> <pre><code># Single config with overrides\npython -m pyamlo config.yml pyamlo.app.name=MyApp pyamlo.database.host=localhost\n\n# Multiple configs with overrides (configs are merged first, then overrides applied)\npython -m pyamlo base.yml production.yml pyamlo.debug=true pyamlo.database.pool_size=20\n\n# Use with special tags\npython -m pyamlo config.yml 'pyamlo.items=!extend [4,5]' 'pyamlo.settings=!patch {\"debug\": true}'\n</code></pre> <p>You can also use overrides programmatically with the <code>load_config</code> function:</p> <pre><code>from pyamlo import load_config\n\n# Manual overrides only\nconfig = load_config(\n    \"config.yml\", \n    overrides=[\"pyamlo.app.name=MyApp\", \"pyamlo.debug=true\"]\n)\n\n# Automatically read CLI overrides from sys.argv\nconfig = load_config(\"config.yml\", use_cli=True)\n\n# Combine manual overrides with CLI overrides\nconfig = load_config(\n    \"config.yml\", \n    overrides=[\"pyamlo.app.name=MyApp\"],  # Manual overrides\n    use_cli=True  # Also read from sys.argv\n)\n</code></pre>"},{"location":"features/#order-of-operations","title":"Order of Operations","text":"<ol> <li>Include Processing: Each config file processes its own <code>!include</code> directives</li> <li>Config Merging: Multiple config files are merged in order (left to right)</li> <li>CLI Overrides: Command-line overrides are applied last</li> <li>Resolution: Variable interpolation and object instantiation occur</li> </ol> <p>CLI overrides support all YAML features and take precedence over file-based configuration.</p>"},{"location":"pytorch-ignite/","title":"PyTorch Ignite with PYAMLO","text":"<p>This guide demonstrates how to use PyTorch Ignite with PYAMLO's YAML configuration system for MNIST digit classification. We'll explore both monolithic and modular configuration approaches.</p>"},{"location":"pytorch-ignite/#overview","title":"Overview","text":"<p>The PyTorch Ignite example showcases how PYAMLO can manage complex machine learning training pipelines through declarative YAML configuration. This approach provides:</p> <ul> <li>Reproducibility: Complete training configuration in version-controlled files</li> <li>Modularity: Split complex configurations into focused, reusable components</li> <li>Flexibility: Easy experimentation with different architectures and hyperparameters</li> <li>Clarity: Human-readable configuration that documents the entire training process</li> </ul>"},{"location":"pytorch-ignite/#files-structure","title":"Files Structure","text":"<pre><code>examples/ignite/\n\u251c\u2500\u2500 data/               # MNIST dataset (auto-downloaded)\n\u251c\u2500\u2500 datasets/\n\u2502   \u2514\u2500\u2500 mnist.yml       # Data pipeline configuration\n\u251c\u2500\u2500 devices/\n\u2502   \u2514\u2500\u2500 auto.yml        # Device detection and configuration\n\u251c\u2500\u2500 evaluators/\n\u2502   \u2514\u2500\u2500 supervised.yml  # Evaluation engine and metrics\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 selector.yml    # Dynamic model selection\n\u2502   \u2514\u2500\u2500 architectures/  # Individual model definitions\n\u2502       \u251c\u2500\u2500 cnn.yml\n\u2502       \u2514\u2500\u2500 resnet.yml\n\u251c\u2500\u2500 trainers/\n\u2502   \u2514\u2500\u2500 supervised.yml  # Training engine and optimizer\n\u251c\u2500\u2500 run_modular.yml     # Modular configuration\n\u2514\u2500\u2500 run_monolithic.yml  # Monolithic configuration\n</code></pre>"},{"location":"pytorch-ignite/#quick-start","title":"Quick Start","text":""},{"location":"pytorch-ignite/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install -e .[ml]  # Install PYAMLO with ML dependencies\n</code></pre>"},{"location":"pytorch-ignite/#run-the-monolithic-configuration","title":"Run the Monolithic Configuration","text":"<p>The monolithic approach puts everything in a single file:</p> <pre><code>cd examples/ignite\npython -m pyamlo run_monolithic.yml\n</code></pre>"},{"location":"pytorch-ignite/#run-the-modular-configuration","title":"Run the Modular Configuration","text":"<p>The modular approach splits configuration into focused components:</p> <pre><code>cd examples/ignite\npython -m pyamlo run_modular.yml\n</code></pre> <p>Both configurations will:</p> <ol> <li>Download MNIST dataset (if not already present)</li> <li>Train a CNN model for 1 epoch</li> <li>Evaluate on the test set</li> <li>Display training progress and final accuracy</li> </ol> <p>First Run</p> <p>The first run will download the MNIST dataset (~9.9 MB), which may take a few moments depending on your internet connection.</p>"},{"location":"pytorch-ignite/#configuration-approaches","title":"Configuration Approaches","text":""},{"location":"pytorch-ignite/#monolithic-configuration-run_monolithicyml","title":"Monolithic Configuration (<code>run_monolithic.yml</code>)","text":"<p>The monolithic configuration demonstrates a complete training pipeline in a single file. This approach is great for:</p> <ul> <li>Quick prototyping</li> <li>Simple experiments</li> <li>Learning how the components work together</li> <li>Small projects with minimal configuration complexity</li> </ul>"},{"location":"pytorch-ignite/#modular-configuration-organized-by-directories","title":"Modular Configuration (organized by directories)","text":"<p>The modular approach organizes configuration into logical directories with focused files, providing several advantages:</p> <ul> <li>Better Organization: Related configurations are grouped together (all models in <code>models/</code>, all datasets in <code>datasets/</code>)</li> <li>Easier Maintenance: Changes to model architecture only require editing files in <code>models/</code></li> <li>Reusability: Components can be easily shared across different experiments</li> <li>Team Collaboration: Multiple team members can work on different components simultaneously</li> <li>Scalability: Easy to add new models, datasets, or training strategies without cluttering</li> </ul>"},{"location":"pytorch-ignite/#1-device-configuration-devicesautoyml","title":"1. Device Configuration (<code>devices/auto.yml</code>)","text":"<p>Automatically detects and configures the appropriate device:</p> <pre><code>cuda: !@torch.cuda.is_available\ndevice: !@torch.device\n  type: \"${'cuda' if cuda else 'cpu'}\"\ndevice_msg: !@print \"Using device: ${device.type}\"\n</code></pre>"},{"location":"pytorch-ignite/#2-data-configuration-datasetsmnistyml","title":"2. Data Configuration (<code>datasets/mnist.yml</code>)","text":"<p>Defines the complete data pipeline:</p> <pre><code># Data transforms for MNIST\ntransform: !@torchvision.transforms.Compose\n  transforms:\n    - !@torchvision.transforms.ToTensor\n    - !@torchvision.transforms.Normalize\n      mean: [0.1307]\n      std: [0.3081]\n\n# Training dataset\ntrain_dataset: !@torchvision.datasets.MNIST\n  root: './data'\n  train: true\n  download: true\n  transform: ${transform}\n\n# Training data loader\ntrain_loader: !@torch.utils.data.DataLoader\n  dataset: ${train_dataset}\n  batch_size: 64\n  shuffle: true\n</code></pre>"},{"location":"pytorch-ignite/#3-model-configuration-modelsselectoryml","title":"3. Model Configuration (<code>models/selector.yml</code>)","text":"<p>Dynamically selects model architecture:</p> <pre><code>model_name: cnn  # Default model\n_model: !include ./architectures/${model_name}.yml\nmodel: ${_model.architecture}\n_model_device_setup: !@pyamlo.call\n  calling: ${model.to}\n  device: ${device}\n</code></pre>"},{"location":"pytorch-ignite/#4-trainer-configuration-trainerssupervisedyml","title":"4. Trainer Configuration (<code>trainers/supervised.yml</code>)","text":"<p>Sets up training components and progress tracking:</p> <pre><code>criterion: !@torch.nn.CrossEntropyLoss\noptimizer: !@torch.optim.Adam\n  params: !@pyamlo.call ${model.parameters}\n  lr: 0.001\n\ntrainer: !@ignite.engine.create_supervised_trainer\n  model: ${model}\n  optimizer: ${optimizer}\n  loss_fn: ${criterion}\n  device: ${device}\n\n# Progress bar for training visualization\npbar: !@ignite.handlers.ProgressBar\n  persist: true\n\nattach_pbar: !@pyamlo.call\n  calling: ${pbar.attach}\n  engine: ${trainer}\n</code></pre>"},{"location":"pytorch-ignite/#5-evaluator-configuration-evaluatorssupervisedyml","title":"5. Evaluator Configuration (<code>evaluators/supervised.yml</code>)","text":"<p>Defines evaluation metrics and testing:</p> <pre><code>metrics:\n  accuracy: !@ignite.metrics.Accuracy\n  loss: !@ignite.metrics.Loss\n    loss_fn: ${criterion}\n  precision: !@ignite.metrics.Precision\n  recall: !@ignite.metrics.Recall\n\nevaluator: !@ignite.engine.create_supervised_evaluator\n  model: ${model}\n  metrics: ${metrics}\n  device: ${device}\n</code></pre>"},{"location":"pytorch-ignite/#6-run-configuration-run_modularyml","title":"6. Run Configuration (<code>run_modular.yml</code>)","text":"<p>Main orchestration file that coordinates all components:</p> <pre><code># include data and model configurations\ninclude!:\n  - ./devices/auto.yml \n  - ./datasets/mnist.yml\n  - ./models/selector.yml\n  - ./trainers/supervised.yml\n  - ./evaluators/supervised.yml\n\nmodel_msg: !@print Model:\\n ${model}\n\n# Start training for 1 epoch\nepochs: 1\ntrain_result: !@pyamlo.call\n  calling: ${trainer.run}\n  start_msg: \"Starting training...\"\n  finish_msg: \"Training completed!\"\n  data: ${train_loader}\n  max_epochs: ${epochs}\n\n# Run evaluation\neval_result: !@pyamlo.call\n  calling: ${evaluator.run}\n  start_msg: \"Running evaluation...\"\n  finish_msg: \"Evaluation completed!\"\n  data: ${val_loader}\n\nresults_msg: !@pprint.pprint ${evaluator.state.metrics}\n</code></pre>"},{"location":"pytorch-ignite/#model-architecture","title":"Model Architecture","text":"<p>The CNN model consists of:</p> <ol> <li>First Conv Block: Conv2d(1\u219232) \u2192 ReLU \u2192 MaxPool2d</li> <li>Second Conv Block: Conv2d(32\u219264) \u2192 ReLU \u2192 MaxPool2d  </li> <li>Classifier: Flatten \u2192 Linear(3136\u2192128) \u2192 ReLU \u2192 Dropout(0.5) \u2192 Linear(128\u219210)</li> </ol> <p>Input: 28\u00d728 grayscale images Output: 10-class probability distribution</p>"},{"location":"pytorch-ignite/#expected-results","title":"Expected Results","text":"<p>Sample Output</p> <p>After running the training, you should see output similar to:</p> <pre><code>Using device: cuda\nIteration: [938/938] 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:20&lt;00:00]\nTraining completed!\nEvaluation completed! {'accuracy': 0.9868, 'loss': 0.040337673950195316}\n</code></pre>"},{"location":"pytorch-ignite/#customization-examples","title":"Customization Examples","text":""},{"location":"pytorch-ignite/#modify-training-parameters","title":"Modify Training Parameters","text":"<p>Edit <code>trainers/supervised.yml</code> to change optimization settings:</p> <pre><code>optimizer: !@torch.optim.SGD\n  params: !@pyamlo.call ${model.parameters}\n  lr: 0.01\n  momentum: 0.9\n</code></pre> <p>Edit <code>run_modular.yml</code> to change training duration:</p> <pre><code>epochs: 5  # Train for more epochs\n\ntrain_result: !@pyamlo.call\n  calling: ${trainer.run}\n  data: ${train_loader}\n  max_epochs: ${epochs}\n</code></pre>"},{"location":"pytorch-ignite/#specific-devices","title":"Specific Devices","text":"<p>Edit <code>devices/auto.yml</code> to set specific device:</p> <pre><code># For CPU only\ndevice: !@torch.device\n  type: \"cpu\"\n\n# For CUDA (if available)  \ndevice: !@torch.device\n  type: \"cuda\"\n\n# For Apple Silicon\ndevice: !@torch.device\n  type: \"mps\"\n</code></pre>"},{"location":"pytorch-ignite/#add-more-metrics","title":"Add More Metrics","text":"<p>Extend the evaluator in <code>evaluators/supervised.yml</code>:</p> <pre><code>metrics:\n  accuracy: !@ignite.metrics.Accuracy\n  loss: !@ignite.metrics.Loss\n    loss_fn: ${criterion}\n  precision: !@ignite.metrics.Precision\n  recall: !@ignite.metrics.Recall\n  f1: !@ignite.metrics.Fbeta\n    beta: 1\n\nevaluator: !@ignite.engine.create_supervised_evaluator\n  model: ${model}\n  metrics: ${metrics}\n  device: ${device}\n</code></pre>"},{"location":"pytorch-ignite/#configuration-overrides","title":"Configuration Overrides","text":"<p>Override configuration values from command line:</p> <pre><code>python -m pyamlo run_modular.yml pyamlo.lr=0.01 pyamlo.epochs=5\n</code></pre>"},{"location":"pytorch-ignite/#data-augmentation","title":"Data Augmentation","text":"<p>Enhance the data pipeline in <code>datasets/mnist.yml</code>:</p> <pre><code>train_transform: !@torchvision.transforms.Compose\n  transforms:\n    - !@torchvision.transforms.ToTensor\n    - !@torchvision.transforms.RandomRotation\n      degrees: 10\n    - !@torchvision.transforms.RandomAffine\n      degrees: 0\n      translate: [0.1, 0.1]\n    - !@torchvision.transforms.Normalize\n      mean: [0.1307]\n      std: [0.3081]\n</code></pre>"},{"location":"pytorch-ignite/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"pytorch-ignite/#conditional-configuration","title":"Conditional Configuration","text":"<p>Use PYAMLO's expression system for conditional behavior:</p> <pre><code># In devices/auto.yml\nis_cuda_available: !@torch.cuda.is_available\ndevice_type: \"${'cuda' if is_cuda_available else 'cpu'}\"\nbatch_size: \"${128 if is_cuda_available else 32}\"  # Larger batch on GPU\n</code></pre>"},{"location":"pytorch-ignite/#dynamic-model-architecture","title":"Dynamic Model Architecture","text":"<p>Create models based on configuration:</p> <pre><code># In model.yml\nhidden_size: 128\nnum_classes: 10\n\nmodel: !@torch.nn.Sequential\n  - !@torch.nn.Flatten\n  - !@torch.nn.Linear\n    in_features: 784  # 28*28\n    out_features: ${hidden_size}\n  - !@torch.nn.ReLU\n  - !@torch.nn.Dropout\n    p: 0.5\n  - !@torch.nn.Linear\n    in_features: ${hidden_size}\n    out_features: ${num_classes}\n</code></pre>"},{"location":"pytorch-ignite/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>Use of environment variables:</p> <pre><code># In trainer.yml\nlearning_rate: !env {var: LEARNING_RATE, default: 0.001}\nbatch_size: !env {var: BATCH_SIZE, default: 64}\nnum_epochs: !env {var: NUM_EPOCHS, default: 1}\n</code></pre>"},{"location":"pytorch-ignite/#dynamic-model-selection","title":"Dynamic Model Selection","text":"<p>PYAMLO supports dynamic model selection through parametrized includes, allowing you to easily switch between different model architectures via CLI overrides.</p>"},{"location":"pytorch-ignite/#model-selector-pattern","title":"Model Selector Pattern","text":"<p>Create a model selector that dynamically includes architecture files based on a parameter:</p> <pre><code># models/selector.yml\nmodel_name: cnn  # Default model\n_model: !include ./architectures/${model_name}.yml\nmodel: ${_model.architecture}\n_model_device_setup: !@pyamlo.call\n  calling: ${model.to}\n  device: ${device}\n</code></pre> <p>Individual architecture files contain their model definitions:</p> <pre><code># models/architectures/cnn.yml\narchitecture: !@torch.nn.Sequential\n  - !@torch.nn.Conv2d [1, 32, 3, 1, 1]\n  - !@torch.nn.ReLU\n  - !@torch.nn.MaxPool2d [2]\n  # ... more layers\n</code></pre> <pre><code># models/architectures/resnet.yml\narchitecture: !@torch.nn.Sequential\n  - !@torch.nn.Conv2d [1, 64, 7, 2, 3, false]\n  - !@torch.nn.BatchNorm2d [64]\n  - !@torch.nn.ReLU [true]\n  # ... more layers\n</code></pre>"},{"location":"pytorch-ignite/#usage","title":"Usage","text":"<p>Switch between models using CLI overrides:</p> <pre><code># Use default CNN model\npython -m pyamlo run_modular.yml\n\n# Switch to ResNet model\npython -m pyamlo run_modular.yml 'pyamlo.model_name=resnet'\n</code></pre>"},{"location":"pytorch-ignite/#best-practices","title":"Best Practices","text":"<ol> <li>Start Simple: Begin with the monolithic configuration to understand the flow</li> <li>Split Gradually: Move to modular configuration as complexity grows</li> <li>Name Meaningfully: Use descriptive names for configuration keys</li> <li>Document Choices: Add comments explaining hyperparameter choices</li> <li>Version Control: Keep configurations in version control alongside code</li> <li>Test Configurations: Validate configurations work before long training runs</li> <li>Use Includes Wisely: Group related configurations together</li> </ol>"},{"location":"pytorch-ignite/#next-steps","title":"Next Steps","text":"<p>This example demonstrates the power of PYAMLO for ML configuration management. Consider exploring:</p> <ul> <li>Different Models: Replace the CNN with ResNet, Transformer, etc.</li> <li>Other Datasets: Adapt the configuration for CIFAR-10, ImageNet, etc.</li> <li>Advanced Training: Add learning rate scheduling, early stopping, checkpointing</li> <li>Hyperparameter Tuning: Use PYAMLO with hyperparameter optimization libraries</li> </ul> <p>The modular approach scales well to complex ML pipelines while maintaining readability and maintainability.</p>"}]}